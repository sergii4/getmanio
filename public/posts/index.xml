<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Terminal, command line, code</title>
    <link>https://getman.io/posts/</link>
    <description>Recent content in Posts on Terminal, command line, code</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 28 Apr 2021 15:56:07 +0100</lastBuildDate><atom:link href="https://getman.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Kubens. DIY with FZF</title>
      <link>https://getman.io/posts/kubens.-diy-with-fzf/</link>
      <pubDate>Wed, 28 Apr 2021 15:56:07 +0100</pubDate>
      
      <guid>https://getman.io/posts/kubens.-diy-with-fzf/</guid>
      <description>In my work daily routine, I often need to switch between namespaces(less frequently contexts) in kubernetes and I used to use kubectx/kubens tools. Recently I started using FZF, mostly as a file finder and for fuzzy search in command line history.
I was wonder if I can apply FZF somewhere else. I tried to make my own kubens. What requirements do I have?
 show all namespaces for the current context select with fuzzy search switch to selected highlight current namespace (optional)  For intermediate scripts I use fish shell, a final script I show in fish shell and bash/zsh.</description>
    </item>
    
    <item>
      <title>Programming Rust in Neovim</title>
      <link>https://getman.io/posts/programming-rust-in-neovim/</link>
      <pubDate>Thu, 22 Apr 2021 11:34:55 +0100</pubDate>
      
      <guid>https://getman.io/posts/programming-rust-in-neovim/</guid>
      <description>Just after I set up my work Go environment in Neovim I was eager to expand this experience to another language. I was wondering how much configuration it requires from me. I was really surpised how easy it turned out.
Rust Installation I installed Rust with Rustup:
$ curl --proto &amp;#39;=https&amp;#39; --tlsv1.2 -sSf https://sh.rustup.rs | sh Then I run, because I faced an issue:
$ rustup update $ rustup comonent add rust-src As LSP server we need a Rust Analyzer.</description>
    </item>
    
    <item>
      <title>Programming Go in Neovim</title>
      <link>https://getman.io/posts/programming-go-in-neovim/</link>
      <pubDate>Wed, 14 Apr 2021 14:43:13 +0100</pubDate>
      
      <guid>https://getman.io/posts/programming-go-in-neovim/</guid>
      <description>There are tons of articles on how to programming Go in vim, how to turn vim into IDE. The purpose of this article is to look closer at nvim as an LSP client, especially for Go.
Intro Nvim introduced nvim-lspconfig, a collection of common configurations for Neovimâ€™s built-in language server client . From that point nvim can be lsp client for any server that supports LSP specification.
My primary setup before was vim with vim-go.</description>
    </item>
    
    <item>
      <title>Gopls</title>
      <link>https://getman.io/posts/gopls/</link>
      <pubDate>Sat, 13 Mar 2021 20:24:51 +0000</pubDate>
      
      <guid>https://getman.io/posts/gopls/</guid>
      <description>Gopls Intro Mid of 2018, I decided to switch from Java to Go. Language change leads to change editor and whole ecosystem and workflow such as doing my job primarily from the terminal.
At the very beginning of my Go journey, I tried Vim as an editor(with vim-go), but I gave up because of a double burden such as learning a new language and a new editor at the same time.</description>
    </item>
    
    <item>
      <title>Anagram Problem Solving</title>
      <link>https://getman.io/posts/anagram-problem-solving/</link>
      <pubDate>Wed, 20 May 2020 13:41:25 +0300</pubDate>
      
      <guid>https://getman.io/posts/anagram-problem-solving/</guid>
      <description>The problem Given an input file that contains one word per line, as an output construct a list of all anagrams from that input file. Print those words to the console, where all words that are an anagram should each other should be on the same line.
Consider aspects such as Maintainability, Scalability, Performance, etc
The steps Read file The only optimization of reading file is reading file line by line to not load the whole into memory.</description>
    </item>
    
    <item>
      <title>Redis delayed tasks with go</title>
      <link>https://getman.io/posts/redis-delayed-tasks-with-go/</link>
      <pubDate>Tue, 05 May 2020 14:13:20 +0300</pubDate>
      
      <guid>https://getman.io/posts/redis-delayed-tasks-with-go/</guid>
      <description>Use Redis as a queue of delayed task If you work on a distributed system it is a high probability that you need some container, queue for sharing info/tasks between components of your system, or even instances of the same component. Let&amp;rsquo;s assume that you need not only queueing but delaying as well.
Probably the first that comes to your mind is Amazon Simple Queue Service (SQS). SQS eliminates the complexity and overhead associated with managing and operating message oriented middleware, and empowers developers to focus on differentiating work.</description>
    </item>
    
    <item>
      <title>Manipulate Unicode in Go</title>
      <link>https://getman.io/posts/manipulate-unicode-in-go/</link>
      <pubDate>Thu, 23 Apr 2020 20:05:22 +0300</pubDate>
      
      <guid>https://getman.io/posts/manipulate-unicode-in-go/</guid>
      <description>We work with string every day. We work we character sets every day. But how much do we know about ASCII, UTF-8, Unicode?
There is the Caesar cipher method:
 The method in which each letter in the plaintext is replaced by a letter some fixed number of positions down the alphabet. The method is named after Julius Caesar, who used it in his private correspondence.
 Assume we have &amp;ldquo;hello worldz&amp;rdquo; and want encode it with shifting by 1.</description>
    </item>
    
    <item>
      <title>Docker, go modules and private repos</title>
      <link>https://getman.io/posts/docker-go-modules-and-private-repos/</link>
      <pubDate>Sun, 29 Mar 2020 20:14:27 +0300</pubDate>
      
      <guid>https://getman.io/posts/docker-go-modules-and-private-repos/</guid>
      <description>Go modules change the way we work with dependency not only locally but in Docker(CI) as well.
First problem we face is caching dependency. It resolves quite simple as docker layer:
 When building an image, Docker steps through the instructions in your Dockerfile, executing each in the order specified. As each instruction is examined, Docker looks for an existing image in its cache that it can reuse, rather than creating a new (duplicate) image.</description>
    </item>
    
  </channel>
</rss>
